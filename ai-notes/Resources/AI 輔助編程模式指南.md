# AI 輔助編程有效模式：新手指南

*與 AI 編程助手高效協作的綜合模式與最佳實踐指南*

## 資料來源
- [Agentic Coding - Armin Ronacher](https://lucumr.pocoo.org/2025/6/12/agentic-coding/) **(Ronacher 2025)**
- [Master Claude Code - YouTube](https://www.youtube.com/watch?v=6eBSHbLKuN0) **(Master Claude Code)**
- [The Perfect Commit - Simon Willison](https://simonwillison.net/2022/Oct/29/the-perfect-commit/) **(Willison 2022)**
- [Two Engineers Ship Like a Team of 15 - YouTube](https://www.youtube.com/watch?v=Lh_X32t9_po) **(Two Engineers 2025)**

## 目錄
1. [快速參考：何時使用哪種模式](#快速參考何時使用哪種模式)
2. [環境設定與工具選擇](#環境設定與工具選擇)
3. [工作流程模式](#工作流程模式)
4. [程式品質與架構](#程式品質與架構)
5. [溝通與情境管理](#溝通與情境管理)
6. [測試與部署](#測試與部署)
7. [平行化與規模化](#平行化與規模化)
8. [效能最佳化](#效能最佳化)

---

## 快速參考：何時使用哪種模式

### 協作強度框架

| **方法** | **使用時機** | **任務特徵** | **範例情境** | **時間投入** |
|----------|-------------|-------------|-------------|-------------|
| **完全自動化** | 小型、明確定義的規格 | - 需求清楚<br>- 已知問題領域<br>- 錯誤風險低 | - Bug 修復<br>- 新增簡單功能<br>- 程式重構 | 低度監督 |
| **一次性引導** | 中等複雜度、熟悉領域 | - 適度複雜<br>- 有些模糊性<br>- 標準模式 | - API 端點建立<br>- 資料庫遷移<br>- 元件開發 | 單次規劃會議 |
| **同步協作** | 高複雜度或不確定性 | - 複雜需求<br>- 新穎問題<br>- 高商業影響<br>- 學習新領域 | - 架構決策<br>- 複雜演算法<br>- 關鍵系統變更 | 持續協作 |
| **平行腦力激盪** | 創意/探索性工作 | - 多種有效方法<br>- 需要多樣觀點<br>- 需要創新 | - 新功能設計<br>- 效能最佳化<br>- 技術研究 | 中等設定，平行執行 |
| **混合引導→擴散** | 大型、多部分專案 | - 複雜但可分解<br>- 團隊學習<br>- 品質一致性需求 | - 完整功能開發<br>- 系統整合<br>- 團隊上手 | 高初期投入，後續可擴展 |

### 任務複雜度決策樹

```
任務是否明確且小型？
├─ 是 → **完全自動化**
└─ 否 → 是否為熟悉領域且中等複雜度？
    ├─ 是 → **一次性引導**
    └─ 否 → 是否為新穎/高影響問題？
        ├─ 是 → **同步協作**
        └─ 否 → 是否需要多種方法？
            ├─ 是 → **平行腦力激盪**
            └─ 否 → 是否為大型且可分解？
                └─ 是 → **混合引導→擴散**
```

### 依風險與複雜度選擇模式

| **風險等級** | **低複雜度** | **中複雜度** | **高複雜度** |
|-------------|-------------|-------------|-------------|
| **低風險** | 完全自動化 | 一次性引導 | 平行腦力激盪 |
| **中風險** | 一次性引導 | 同步協作 | 混合引導 |
| **高風險** | 同步協作 | 同步協作 | 同步協作 |

### 時間 vs. 品質權衡

| **優先級** | **快速交付** | **平衡** | **最高品質** |
|----------|-------------|---------|-------------|
| **方法** | 完全自動化 → 一次性 | 混合引導 | 同步協作 |
| **適用於** | 原型、快速修復 | 生產功能 | 關鍵系統 |

---

## 環境設定與工具選擇

### 程式語言與框架偏好
- **選擇穩定、對 AI 友善的語言**：推薦使用 Go 進行後端專案，因其明確的上下文系統、簡單的測試快取與低生態系統流動性 *(Ronacher 2025)*
- **避免快速變化的生態系統**：JavaScript/Node.js 生態系統因頻繁變化而具挑戰性 *(Ronacher 2025)*
- **優先考慮簡潔性**：語法清晰直接的語言與 AI 助手配合更佳 *(Ronacher 2025)*

### 工具設計原則
- **速度至關重要**：快速編譯與執行能提升 AI 代理生產力 *(Ronacher 2025)*
- **使用者友善設計**：工具不應當機、應提供良好錯誤訊息與可偵錯性 *(Ronacher 2025)*
- **可觀察性**：記錄到檔案（而非僅終端機），讓 AI 代理能調查問題 *(Ronacher 2025)*
- **保護措施**：在自動化模式下使用容器化（如 Docker）進行風險管控 *(Raw Notes)*
- **避免服務衝突**：使用防止重複服務生成的工具（如 pidfiles） *(Raw Notes)*
- **熱重載模式**：對於慢應用程式，建立可動態載入程式碼的守護程序 *(Raw Notes)*

### 自動化模式設定
- **YOLO 模式**：使用 `--dangerously-skip-permissions` 進行完全自動化工作流程 *(Raw Notes)*
- **安全自動化**：始終在 Docker 容器內執行自動化模式以提供保護 *(Raw Notes)*
- **MCP 使用**：除非必要（如瀏覽器自動化的 Playwright MCP），否則避免使用 MCP *(Raw Notes)*

### 開發環境
- **終端機基礎工具**：啟用腳本化與平行執行 *(Master Claude Code)*
- **SSH/tmux 支援**：允許同時執行多個會話 *(Master Claude Code)*
- **語音輸入設定**：語音輸入可加速與 AI 助手的溝通 *(Master Claude Code)*
- **工作區組織**：使用允許工具配置與終端機設定 *(Master Claude Code)*
- **多模態支援**：拖放圖片、使用檔案路徑或直接複製貼上圖片 *(Master Claude Code)*
- **無需索引**：程式碼保持本地，無遠端資料庫，不會訓練您的程式碼 *(Master Claude Code)*

### 入職與團隊設定
- **從問答開始，而非編程**：團隊入職時，先從程式庫問題開始再進行編輯 *(Master Claude Code)*
- **加速入職**：可將技術入職從數週縮短至數天 *(Master Claude Code)*
- **權限邊界**：學習什麼可以「一次完成」vs. 需要引導 *(Master Claude Code)*

---

## 工作流程模式

### 核心工作流程：探索 → 規劃 → 確認 → 編程 → 提交 *(Master Claude Code)*
1. **探索**：使用 @ 標籤、問答與入職來理解程式庫 *(Master Claude Code)*
2. **規劃**：讓 AI 腦力激盪或在編程前建立詳細計畫 *(Master Claude Code)*
3. **確認**：在實作前審查與核准計畫 *(Master Claude Code)*
4. **編程**：實作解決方案 *(Master Claude Code)*
5. **提交**：建立原子性、文件完整的提交 *(Master Claude Code)*

### 替代工作流程
- **測試驅動開發**：撰寫測試 → 提交 → 編程 → 迭代 → 提交 *(Master Claude Code)*
- **AI 輔助 TDD**：AI 撰寫測試（仔細審查）→ AI 實作 → 重構直到測試通過 *(Raw Notes)*
- **視覺化開發**：撰寫程式碼 → 截圖（使用 Playwright/Puppeteer）→ 迭代 *(Master Claude Code)*
- **模型驅動開發**：拖放 UI 模型 → AI 實作 → 使用截圖迭代 *(Master Claude Code)*
- **平行腦力激盪**：使用 3 個平行代理在實作前腦力激盪 *(Master Claude Code)*
- **CLI/SDK 整合**：將 Claude Code 當作 Unix 工具使用 - 管道輸入/輸出、JSON 格式化 *(Master Claude Code)*

### 規劃策略
- **分解複雜任務**：使用 todo.md 檔案進行專案規劃 *(Raw Notes)*
- **問題驅動規劃**：詢問「優秀的 PM 會問什麼問題？」 *(Two Engineers 2025)*
- **專注於使用者故事**：以使用者需求為中心進行規劃 *(Two Engineers 2025)*
- **尋找危險信號**：在規劃階段早期識別潛在問題 *(Two Engineers 2025)*
- **訪談模式**：在產生解決方案前詢問使用者更多情境 *(Two Engineers 2025)*
- **讓計畫更有吸引力**：提出問題並專注於使用者故事讓計畫更易讀 *(Two Engineers 2025)*

### 不僅僅是編程 *(Two Engineers 2025)*
- **功能研究工作流程**：基礎研究 → 研究現有程式庫 → 研究最佳實踐 → 規劃 → 獲得批准 → 建立 GitHub issue
- **開發生命週期整合**：將 AI 用於所有開發相關任務，而非僅僅編程
- **早期介入**：在規劃階段而非部署後修復問題

---

## 程式品質與架構

### 程式風格與模式
- **撰寫簡單直接的程式碼**：偏好函數而非複雜類別 *(Ronacher 2025, Raw Notes)*
- **使用純 SQL**：盡可能避免複雜的 ORM *(Ronacher 2025, Raw Notes)*
- **保持重要檢查的本地性**：權限與關鍵邏輯應可見且本地化 *(Ronacher 2025)*
- **偏好程式碼生成而非依賴**：減少依賴管理負擔 *(Ronacher 2025)*
- **最小依賴**：盡可能自己撰寫程式碼以避免升級/修補問題 *(Raw Notes)*

### 架構原則
- **讓事物可平行化**：設計支援併發執行 *(Raw Notes)*
- **啟用簡易重構**：規劃程式碼演進與複雜度管理 *(Raw Notes)*
- **專注於可維護性**：撰寫對人類與 AI 都易懂的程式碼 *(Ronacher 2025)*
- **使用結構化介面**：清晰明確的介面改善 AI 理解 *(Ronacher 2025)*

---

## 溝通與情境管理

### 使用 CLAUDE.md 的情境管理 *(Master Claude Code)*
在不同層級建立情境檔案：
- **企業層級**：組織範圍的模式與標準 *(Master Claude Code)*
- **全域層級**（`~/.claude/CLAUDE.md`）：個人偏好與工具 *(Master Claude Code)*
- **專案層級**（已檢入）：共享團隊情境 *(Master Claude Code)*
- **專案層級**（本地）：個人專案特定筆記 *(Master Claude Code)*

包含：
- 常用任務的 Bash 指令 *(Master Claude Code)*
- 架構決策 *(Master Claude Code)*
- 重要檔案位置 *(Master Claude Code)*
- 團隊工具與 MCP 配置 *(Master Claude Code)*

### 有效溝通
- **要求 Claude 先腦力激盪**：在實作前獲得多種方法 *(Master Claude Code)*
- **提供清晰情境**：使用 @ 標籤引用特定檔案 *(Master Claude Code)*
- **明確需求**：清楚的需求導致更好的結果 *(Master Claude Code)*
- **要求解釋**：讓 AI 解釋其複雜任務的方法 *(Master Claude Code)*
- **使用特定提示**：「在撰寫程式碼前，制定計畫」或「制定計畫，讓我審查，請求批准」 *(Master Claude Code)*
- **Git 整合**：詢問 Git 歷史、提交格式、誰引入了變更 *(Master Claude Code)*
- **週會**：「我這週交付了什麼？」進行自動化狀態報告 *(Master Claude Code)*

### 互動會話管理 *(Master Claude Code)*
- **Escape 中斷**：按 escape 給予任務中途回饋或修正
- **會話恢復**：使用 `--resume` 或 `--continue` 恢復先前會話
- **歷史導航**：按兩次 escape 在會話歷史中跳轉

---

## 測試與部署

### 測試策略
- **綜合測試**：包含實作測試與文件 *(Willison 2022)*
- **冒煙測試**：快速驗證核心功能是否運作 *(Two Engineers 2025)*
- **視覺化測試**：使用 Figma → Puppeteer → 截圖 → 程式碼更新工作流程 *(Two Engineers 2025)*
- **提示評估**：將提示視為程式碼 - 測試它們、測量成功率、迭代 *(Two Engineers 2025)*
- **迭代自我修正**：讓 AI 系統透過測試回饋修復自身問題 *(Two Engineers 2025)*

### 完美提交模式 *(Willison 2022)*
每個提交應包含：
1. **單一、專注的變更**：一個原子性改進 *(Willison 2022)*
2. **證明變更有效的測試**：綜合測試覆蓋 *(Willison 2022)*
3. **更新的文件**：反映變更 *(Willison 2022)*
4. **問題/情境連結**：提供進一步背景 *(Willison 2022)*

### 部署實踐
- **保持主分支可部署**：確保提交不會破壞建置 *(Willison 2022)*
- **原子性提交**：每個提交應自包含且可審查 *(Willison 2022)*
- **清晰的提交訊息**：專注於「為什麼」而非「什麼」 *(Willison 2022)*
- **使用分支進行實驗**：將實驗性工作與主線分離 *(Willison 2022)*

---

## 平行化與規模化

### 平行開發方法
- **多個 Claude 實例**：平行執行不同工作流程 *(Master Claude Code)*
- **Git worktrees**：同時在多個分支上工作 *(Master Claude Code)*
- **GitHub Actions**：自動化平行工作流程 *(Master Claude Code)*
- **Claude Squad 管理**：從中央位置協調多個 AI 助手 *(Raw Notes)*

### 任務分配
- **平行執行不同工作**：將不同功能分配給不同實例 *(Raw Notes)*
- **平行問題解決**：讓多個實例解決同一問題並選擇最佳方法 *(Raw Notes)*
- **研究平行化**：同時執行研究任務以加速資訊收集 *(Two Engineers 2025)*

### 混合方法 *(Raw Notes)*
- **與 AI 討論計畫**：質疑並驗證理解 *(Raw Notes)*
- **試用一個實例**：用單一案例測試方法 *(Raw Notes)*
- **提供回饋**：對方法給予輸入 *(Raw Notes)*
- **擴展到多個代理**：擴散到多個子代理進行平行執行 *(Raw Notes)*

---

## 效能最佳化

### 速度最佳化
- **快速工具回應**：最小化工具互動延遲 *(Ronacher 2025)*
- **快速編譯**：選擇編譯/執行快速的語言與工具 *(Ronacher 2025)*
- **高效 token 使用**：最佳化 token 效率以降低成本 *(Ronacher 2025)*
- **最小化中斷**：允許代理以最少介入完成任務 *(Ronacher 2025)*

### 資源管理
- **使用更便宜的模型**：在許多任務中使用 Claude Sonnet 而非更昂貴的模型 *(Ronacher 2025)*
- **有效快取**：為重複操作實作快取 *(Ronacher 2025)*
- **批次操作**：群組相關任務以減少負擔 *(Ronacher 2025)*
- **最佳化推理成本**：設計工作流程以最小化 API 呼叫 *(Ronacher 2025)*

### 工作流程效率
- **容器化**：使用 Docker 進行安全的自動執行 *(Raw Notes)*
- **守護程序模式**：為常用工具建立長時間執行的程序 *(Ronacher 2025)*
- **檔案系統監控**：實作熱重載模式以快速迭代 *(Ronacher 2025)*
- **記錄策略**：結構化記錄以改善除錯與監控 *(Ronacher 2025)*
- **分層權限系統**：為安全的 bash 指令執行設計複雜的允許/阻擋清單 *(Master Claude Code)*
- **靜態分析**：自動偵測安全指令組合 *(Master Claude Code)*

---

## 進階模式

### 複合工程師方法 *(Two Engineers 2025)*
- **生成提示的提示**：建立能產生更好提示的 AI *(Two Engineers 2025)*
- **自我改進工作流程**：建立能增強自身程序的系統 *(Two Engineers 2025)*
- **知識累積**：基於先前工作建立複合效果 *(Two Engineers 2025)*

### 元開發模式
- **完整生命週期整合**：將 AI 用於編程以外 - 研究、規劃、問題建立 *(Two Engineers 2025)*
- **自我修復系統**：建立 AI 能調查與修復自身錯誤的系統 *(Raw Notes)*
- **動態程式載入**：對於慢應用程式，建立快速迭代的熱重載系統 *(Raw Notes)*

### 品質保證
- **在週期早期修復**：在規劃而非部署後處理問題 *(Two Engineers 2025)*
- **多重驗證層**：使用不同方法驗證正確性 *(Two Engineers 2025)*
- **持續評估**：定期評估 AI 系統效能 *(Two Engineers 2025)*
- **回饋迴路**：從錯誤中學習以改善未來效能 *(Two Engineers 2025)*

### 研究與開發
- **基礎研究**：在提議變更前理解現有程式庫 *(Two Engineers 2025)*
- **最佳實踐研究**：研究業界標準與模式 *(Two Engineers 2025)*
- **計畫驗證**：在實作前與利害關係人檢查計畫 *(Two Engineers 2025)*
- **問題追蹤**：為功能請求與錯誤建立 GitHub issues *(Two Engineers 2025)*

---

## 入門檢查清單

對於開始 AI 輔助編程的新手：

1. **設定您的環境**
   - [ ] 安裝 Claude Code 或類似的 AI 編程助手
   - [ ] 配置終端機與 shell 以最佳化工作流程
   - [ ] 設定允許工具與權限

2. **建立您的 CLAUDE.md 檔案**
   - [ ] 在 `~/.claude/CLAUDE.md` 進行全域配置
   - [ ] 專案特定情境檔案
   - [ ] 記錄常用指令與架構決策

3. **建立工作流程**
   - [ ] 練習 探索 → 規劃 → 確認 → 編程 → 提交 模式
   - [ ] 嘗試使用 AI 輔助的測試驅動開發
   - [ ] 實驗平行腦力激盪

4. **專注於程式品質**
   - [ ] 撰寫簡單、可讀的程式碼
   - [ ] 最小化依賴
   - [ ] 規劃重構與演進

5. **實驗與迭代**
   - [ ] 嘗試不同方法找出適合您團隊的方式
   - [ ] 根據您的特定領域與需求調整模式
   - [ ] 隨著領域快速發展持續實驗

記住：AI 輔助編程的「好」方法正在快速變化。保持適應性並持續嘗試新工具與技術。*(Ronacher 2025)*